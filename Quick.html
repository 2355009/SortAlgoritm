<link rel="stylesheet" href="style.css">
<body bgcolor="white">
    <center>
        <h1>퀵 정렬</h1>
        <br>
        <br>
        <br>
        <br>
        <h2>퀵정렬이란?</h2>
       <br><br><br><br>
        <img src="https://mblogthumb-phinf.pstatic.net/MjAxNzA0MDVfMTU5/MDAxNDkxMzk4MzU0ODQz.ddoOoZpceGeNZNj2c_UtsZkB0phFMxLdT0yvIYy0vVcg.DTdMEze8AfCYfBF2n9b2PvwY3dgEJPgwcx7s15i_lecg.PNG.aufcl4858/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2017-04-05_%EC%98%A4%ED%9B%84_10.18.55.png?type=w2" width="43.5%" border="1"><br>
        <pictext>출처 :<a href="https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=aufcl4858&logNo=220976189786" target="_blank">마스터 누누 [알고리즘] Sort - 퀵정렬(Quick sort)</a> </pictext><br><br><br><br>
        <h2>C++로 구현한 퀵정렬</h2>
        <table width="100%">
            <tr><td width="10%"></td><td width="80%" bgcolor="black"><font color="green"><pre>

                #include "header.h"

                int MergeSort(int** data,int count) {
                    int size = _msize(*data) / sizeof(int);
                    if (size < 2)
                        return count;
                    int leftsize = size / 2, rightsize = size - leftsize;
                    int* left = new int[leftsize];
                    int* right = new int[rightsize];
                    for (int i = 0; i < leftsize; i++)
                        *(left + i) = *(*data + i);
                    for (int i = 0; i < rightsize; i++)
                        *(right + i) = *(*data + i + leftsize);
                    count=MergeSort(&left, count);
                    count=MergeSort(&right, count);
                    int leftnow = 0, rightnow = 0, now = 0;
                    while (leftnow < leftsize && rightnow < rightsize) {
                        if (left[leftnow] < right[rightnow]) {
                            *((*data) + now) = *(left + leftnow);
                            leftnow++;
                            now++;
                        }
                        else {
                            *((*data) + now) = *(right + rightnow);
                            rightnow++;
                            now++;
                        }
                    }
                    while (leftnow < leftsize) {
                        *((*data) + now) = *(left + leftnow);
                        leftnow++;
                        now++;
                    }
                    while (rightnow < rightsize) {
                        *((*data) + now) = *(right + leftnow);
                        rightnow++;
                        now++;
                    }
                    delete[] right;
                    delete[] left;
                    count += leftnow;
                    return count;
                }
                int QuickSort(int** data, int count){
                    int leftsize = 0, rightsize = 0,pivot= *((*data)),size= _msize(*data) / sizeof(int);
                    if (size < 2)
                        return count;
                    for (int i = 1; i < size; i++) {
                        if (*((*data) + i) < pivot)
                            leftsize++;//pivot보다 작은 숫자의 갯수를 구하는 코드
                        else
                            rightsize++;//pivot보다 큰 숫자의 갯수를 구하는 코드
                    }
                    int* left = new int[leftsize], * right = new int[rightsize];
                    int leftnow = 0, rightnow = 0;
                    for (int i = 1; i < size; i++) {
                        if (*((*data) + i) < pivot)
                        {
                            *(left + leftnow) = *((*data) + i);//left에 데이터 넣기
                            leftnow++;
                        }
                        else
                        {
                            *(right + rightnow) = *((*data) + i);//right에 데이터 넣기
                            rightnow++;
                        }
                    }
                    count=QuickSort(&left, count);
                    count=QuickSort(&right, count);
                    for (int i = 0; i < leftsize; i++)
                        *(*data + i) = *(left + i);
                    *(*data + leftsize) = pivot;
                    for (int i = 0; i < rightsize; i++)
                        *(*data +1+ leftsize + i) = *(right + i);
                    delete[] right;
                    delete[] left;
                    count += leftnow;
                    return count;
                }
                void BadSetting(int** data) {
                    int size = _msize(*data) / sizeof(int);
                    for (int i = 0; i < size; i++)
                        *(*data + i) = size - i;
                }

            </pre></font></td><td width="10%"></td></tr>
        </table><br><pictext>자세한 코드는 <a href="Algoritm\src\header.cpp" target="_blank">여길</a> 참고해주세요</pictext>
        <br><br><br><br><h2>최악의 경우의 퀵정렬</h2>
         <img src="img\QuickSort.png" width="50%">
    </center>
</body>